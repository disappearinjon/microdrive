package mdturbo

import (
	"fmt"
	"testing"
)

func TestValidate(t *testing.T) {
	var partTable MDTurbo
	Part0 := Partition{Start: 256, Length: 65536}

	if partTable.Validate() {
		t.Errorf("empty part table validated successfully")
	}
	partTable.Magic = 52426 // It's magic, okay?
	if partTable.Validate() {
		t.Errorf("magic-only part table validated successfully")
	}
	partTable.Partitions1[0] = Part0
	if !partTable.Validate() {
		t.Errorf("valid partition table failed to validate")
	}
}

func TestDeserializeTooShort(t *testing.T) {
	badData := make([]byte, 511, 511)
	_, err := Deserialize(badData)
	if err == nil {
		t.Errorf("too-short partition table deserialized successfully")
	}
}

func TestDeserialize(t *testing.T) {
	var partitionChecks = []struct {
		number, start, length uint32
	}{
		{0, 256, 65535},
		{1, 65791, 65535},
		{2, 131326, 65535},
		{3, 196861, 65535},
		{4, 262396, 65535},
		{5, 327931, 65535},
		{6, 393466, 65535},
		{7, 459001, 65535},
	}

	partmap, err := Deserialize(testData)
	if err != nil {
		t.Errorf("correctly-sized partition table failed to deserialize")
	}
	if !partmap.Validate() {
		t.Errorf("valid partition table failed to validate")
	}
	if partmap.Cylinders != 995 {
		t.Errorf("cylinder count incorrect (got %d, wanted %d)", partmap.Cylinders, 995)
	}
	if partmap.Heads != 16 {
		t.Errorf("head count incorrect (got %d, wanted %d)", partmap.Heads, 16)
	}
	if partmap.Sectors != 63 {
		t.Errorf("sector count incorrect (got %d, wanted %d)", partmap.Sectors, 63)
	}
	if partmap.PartCount1 != 8 {
		t.Errorf("partition 1 count incorrect (got %d, wanted %d)", partmap.PartCount1, 8)
	}
	if partmap.PartCount2 != 0 {
		t.Errorf("partition 2 count incorrect (got %d, wanted %d)", partmap.PartCount2, 0)
	}
	if partmap.RomVersion != 3 {
		t.Errorf("ROM version incorrect (got %d wanted %d)", partmap.RomVersion, 3)
	}

	for _, tt := range partitionChecks {
		testname := fmt.Sprintf("partcheck-%d", tt.number)
		t.Run(testname, func(t *testing.T) {
			start := partmap.Partitions1[tt.number].Start
			if start != tt.start {
				t.Errorf("got %d, wanted %d", start, tt.start)
			}
			length := partmap.Partitions1[tt.number].Length
			if length != tt.length {
				t.Errorf("got %d, wanted %d", start, tt.length)
			}
		})
	}

}

// TEST PARTITION DATA

// Totally Standard Partition Table
// command to generate test data in appropriate format is:
// xxd -g 1 -l 512 -c 8 -i FILENAME -
var testData = []byte{
	0xca, 0xcc, 0xe3, 0x03, 0x04, 0x00, 0x10, 0x00,
	0x3f, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xdd, 0x00, 0x48, 0x00,
	0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0xff, 0x00, 0x01, 0x00,
	0xfe, 0x00, 0x02, 0x00, 0xfd, 0x00, 0x03, 0x00,
	0xfc, 0x00, 0x04, 0x00, 0xfb, 0x00, 0x05, 0x00,
	0xfa, 0x00, 0x06, 0x00, 0xf9, 0x00, 0x07, 0x00,
	0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
	0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
	0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
	0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
}
